<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimDriver: Model capabilities, behavior and features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimDriver
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Model capabilities, behavior and features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Capability description</h2>
<ul>
<li>[x] 1. Holding the vehicle in standstill by using the <em>brake pedal</em></li>
<li>[x] 2. Controlling a <em>desired acceleration</em> by using <em>drive</em> and <em>brake pedal</em></li>
<li>[x] 3. Controlling a <em>desired speed</em></li>
<li>[x] 4. Controlling predictively a <em>desired speed</em> in a given <em>distance</em></li>
<li>[x] 5. Controlling the vehicle to stop within a <em>desired distance</em></li>
<li>[x] 6. Controlling a <em>desired distance</em> to a preceding vehicle</li>
<li>[x] 7. Controlling a <em>desired curvature</em> by using the <em>steering</em></li>
<li>[x] 8. Following <em>reference points</em></li>
<li>[x] 9. Following <em>desired track points</em> (horizon)</li>
<li>[x] 10. Controlling a <em>desired lateral offset</em> to a given track</li>
<li>[x] 11. Switching from the current path to <em>another</em> smoothly</li>
<li>[x] 12. Following other <em>road participants</em> in the traffic flow</li>
<li>[x] 13. Keeping a maximum comfortable speed in curves (depending on the <em>maximum lateral acceleration</em>)</li>
<li>[x] 14. Keeping a maximum allowed speed (defined by <em>speed rules</em>, e.g. speed limits)</li>
<li>[x] 15. Keeping a <em>maximum comfortable speed</em> defined by a parameter</li>
<li>[x] 16. Adapting the speed predictively according to the local speeds (12., 13., 14.)</li>
<li>[o] 17. Making <em>decision</em> and <em>performing</em> a lane change</li>
<li>[x] 18. Making <em>decision</em> to stop at stop signs</li>
<li>[ ] 19. Making <em>decision</em> to slow down or stop due to a conflict ahead</li>
</ul>
<h3>Capability feature 1: Holding the Vehicle in Standstill</h3>
<p>The implementation can be found in <code><a class="el" href="classAgentModel.html#a1c3c4292cbcb9de88226082c4088cd88">AgentModel::subconsciousStartStop()</a> -&gt; double</code>. The function returns the target pedal value. A P-controller sets the vehicle pedal value accordingly.</p>
<p><b>Objective:</b></p>
<p>Hold the vehicle in standstill (v = 0) such that the vehicle does not move.</p>
<p><b>Initial situation:</b></p>
<p>The agent slows down (feature #4 or feature #5) to come to a stop. When a minimum velocity is reached, the agent activates this feature.</p>
<p>Relevant initial states are, if</p><ol type="1">
<li>the vehicle has already stopped (v = 0),</li>
<li>the vehicle is still moving (v &gt; 0).</li>
</ol>
<p><b>Execution:</b></p>
<p>By setting the flags <code>state.conscious.stop.standing</code> or <code>state.conscious.follow.standing</code> the feature is activated. When activated, the pedal value is set to <code>param.stop.pedalDuringStanding</code> (see <a href="#parameters">Parameters</a>), otherwise the pedal value is set to infinity (direct pedal control deactivated).</p>
<p><b>Behavior:</b></p>
<ol type="1">
<li>The vehicle is kept in standstill if $v=0$ (Test 1.1)</li>
<li>From a velocity v &lt; 10 m/s, the vehicle stops and reaches the target pedal value within 5 seconds within 7 seconds. The deceleration is slightly below -2 m/s<sup>2</sup> (Test 1.2).</li>
</ol>
<p><b>Output:</b></p>
<p>The output of the controller is the input pedal value for the vehicle model.</p>
<h3>Capability feature 2: Controlling a desired acceleration</h3>
<p>The implementation can be found in <code><a class="el" href="classAgentModel.html#a14b5a6c7ba08e7b441ac737cfdaae11b">AgentModel::step(double simulationTime)</a></code>. The function calculates the desired acceleration. A PI-controller calculates the corresponding pedal value.</p>
<p><b>Objective:</b></p>
<p>Accelerate the vehicle exactly with a desired acceleration.</p>
<p><b>Limitations:</b></p>
<p>The acceleration is limited by the dynamics of the vehicle model. Basically, the max. acceleration is a function of the maximum power, the mass and the actual velocity of the vehicle. The maximum deceleration is basically limited by the maximum brake torque.</p>
<p><b>Initial situation</b></p>
<p>The agent uses controlled acceleration when</p><ul>
<li>the agents wants to reach the desired speed (feature #3), or</li>
<li>the agent approaches and keeps distance to a preceding road participant (feature #6), or</li>
<li>the agent is going to stop the vehicle (feature #5).</li>
</ul>
<p><b>Execution:</b></p>
<p>By setting the signal <code>state.subconscious.a</code>, the PI pedal controller sets a pedal value and compensates errors between desired and actual acceleration by a change in the drive or brake pedal.</p>
<p>Within the normal behavior, A sum of reaction values for velocity control, stop control and distance control during following are calculated to the resultant desired acceleration, based on the Intelligent Driver Model (IDM) [1].</p>
<p><b>Behavior:</b></p>
<p>The agent model compensates large acceleration errors within 5 seconds to an error below 0.01 m/s<sup>2</sup>. This expression is valid for realistic accelerations within the limitations of the vehicle model. The behavior can be adapted by the PI pedal controller. A large I parameter value leads to quick and accurate control of the acceleration with an overshoot, when steps are compensated. A low I parameter value leads to no overshoot, but a very low error is reached within a larger time period.</p>
<p><b>Output:</b></p>
<p>The output of the controller is the input pedal value for the vehicle model.</p>
<h3>Capability feature 3: Controlling a desired speed</h3>
<p>The implementation can be found in <code><a class="el" href="classAgentModel.html#a14b5a6c7ba08e7b441ac737cfdaae11b">AgentModel::step(double simulationTime)</a></code>. The function calculates the desired acceleration.</p>
<p>Feature chain: Desired velocity &rarr; desired acceleration (feature 2) &rarr; pedal value (pedal controller) &rarr; actual pedal position (VM) &rarr; actual acceleration (VM) &rarr; actual velocity.</p>
<p><b>Objective:</b></p>
<p>Accelerate or decelerate the vehicle to reach and hold a desired velocity.</p>
<p><b>Limitations</b></p>
<p>The velocity of teh vehicle is limited by the dynamics of the vehicle model. Basically, the max. velocity is a function of the maximum power of the vehicle (and resistance parameters). The minimum velocity is zero. Backwards driving is not implemented, yet.</p>
<p><b>Initial situation</b></p>
<p>The agent uses the velocity control continuously</p><ul>
<li>to limit the desired curve speed (feature #12), and</li>
<li>to avoid exceeding the permitted maximum speed (feature #13), and</li>
<li>to avoid exceeding the max. comfortable cruise speed (feature #14).</li>
</ul>
<p><b>Execution:</b></p>
<p>By setting the signals <code>state.conscious.velocity.comfort</code>, <code>state.conscious.velocity.curve</code>, <code>state.conscious.velocity.rule</code>, the agent model calculates a desired acceleration.</p>
<p>The minimum of the stated velocities is calculated and set as local maximum velocity. Based on the IDM [1], the acceleration is calculated.</p>
<p><b>Behavior:</b></p>
<p>The agent model accelerates or decelerates to reach the desired velocity from the actual velocity (velocity step). With decreasing the step, the actual acceleration decreases as well until, when the desired velocity is reached, the acceleration is zero. The time interval in which the velocity is reached, strongly depends on the velocity step and the acceleration parameter <code>_param.velocity.a</code>. The parameter defines the maximum acceleration to compensate velocity steps. Starting from v = 0, the agent model accelerates with the maximum acceleration set by the parameter.</p>
<p>With a maximum acceleration set to 2.0 m/s<sup>2</sup>, the agent model reaches a velocity of 100 kph (27.8 m/s) within 30 seconds with an remaining error of less than 0.1 m/s (~99.8 %). Another performance factor for this feature is, that each velocity between 0 and 30 m/s is reached by at least 0.2 m/s within the time interval equal to the step (T_0.2 = (v_desired - v_actual))</p>
<p><b>Output:</b></p>
<h2>Parameters</h2>
<p>TODO</p>
<h3>Input-Interface</h3>
<p>The inputs required by the driver model are divided into five sub-structures:</p><ul>
<li><b>vehicle:</b> represents the vehicle state</li>
<li><b>horizon:</b> a corridor in which the driver model plans its behavior</li>
<li><b>signals:</b> array of relevant signals along the route</li>
<li><b>lanes:</b> array of surrounding lanes relative to the driver's lane</li>
<li><b>targets:</b> array of all moving objects around the driver</li>
</ul>
<p>Each quantity is documented in Doxygen style within <code>AgentModelInterface.h</code>. However, in the following some remarks on important structures are described in more detail.</p>
<h4>Horizon</h4>
<p>The most sensitive interface is the horizon because the driver model uses it to plan its longitudinal and lateral movement. First, the entries of a single horizon knot are described followed by instructions on how the horizon knots shall be arranged around the driver model.</p>
<h5>Knots</h5>
<p>Every knot is located in the lane center of the current ego lane. At each knot the $x,y$-coordinates relative to the ego coordinate system have to specified. Further, the distance $ds$ along $s$ needs to be specified. Here, often it is sufficient to take the distances along the reference line (if the horizon is generated from an OpenDRIVE map). Note: in very narrow curves this simplification might not be adequate. The same assumptions are valid for the curvature $$ at each horizon knot. Positive curvature values correspond to left turns in positive $s$-direction. The angle $$ is defined as the road's heading relative to ego-coordinate x-axis. Last, the lane width of the ego lane and its left and right neighbor has to be specified at each horizon knot.</p>
<p>In Fig. 1 an example for each entry of one horizon knot is illustrated.</p>
<div class="image">
<object type="image/svg+xml" data="../resources/doc/img/horizonSketch.svg" width="750"></object>
</div>
<p><em>Fig 1: Horizon sketch</em></p>
<h5>Horizon Arrangement</h5>
<p>The position and amount of horizon knot along $s$ are theoretically arbitrary. However, we provide some recommended rules to generate the horizon in order to achieve the best possible driver model behavior.</p>
<ol type="1">
<li>The number of horizon knots <code>NOH</code> is currently $32$. This has been found as a good tradeoff in terms of efficiency and accuracy</li>
<li>The maximum horizon distance is not constant but dependent on the current speed. Here, $ds_{max} = 20 {sec} * v_x$ has been proved to be good.</li>
<li>It is advised to place the first horizon a little behind the ego vehicle because of some interpolations inside the driver model. A good value is $ds_0=-1{sec}*v_x$</li>
<li>The knot distribution along $s$ between the first and last horizon knot can be chosen arbitrarily. However, linear or quadratic increasing distance both leads to good behavior.</li>
<li>If horizon knots are behind the end of a road, set $ds=$. The driver model then will ignore the respective knots</li>
</ol>
<h4>Lanes</h4>
<p>Up to <code>NOL</code> lanes can be send to the driver model. <code>NOL</code> is currently $32$ but often fewer lanes are sufficient. Some remarks on the lane id:</p><ul>
<li>The <code>id</code> is not just an identifier but also indicates the position relative to the ego lane. Examples: <code>id=</code><ul>
<li>$0$ : ego lane</li>
<li>$-1$ : next lane to the left relative to the ego vehicle</li>
<li>$1$ : next lane to the right relative to the ego vehicle</li>
<li>$127$ : indicates that there is no lane entry (because the interface is of static length)</li>
</ul>
</li>
<li>Lanes do not need to sorted by their id</li>
</ul>
<p>All other entries are described in <code>src/AgentModelInterface.h</code> under <code>struct Lane {...}</code>.</p>
<h4>Targets</h4>
<p>The required quantities for surrounding targets is documented straightforward in <code>src/AgentModelInterface.h</code> under <code>struct Target {...}</code>.</p>
<h4>Signals</h4>
<p>Signals may be</p><ul>
<li>Stop signs (<code>SIGNAL_STOP</code>)</li>
<li>Traffic lights (<code>SIGNAL_TLS</code>)</li>
<li>Speed limits (<code>SIGNAL_SPEED_LIMIT</code>)</li>
</ul>
<p>Additionally to its type, a signal must be equipped with a unique id, the distance along $s$ to the signal and a value. The value is irrelevant for stop signs. Speed limits are given in <code>m/s</code>. A concept for traffic lights will follow in a later development stage.</p>
<h3>Output-Interface</h3>
<p>There is no distinct output interface. However, the final state of the driver (behavior) model is the desired acceleration $a_{des}$ and the desired curvature $</p><div class="dotgraph">
<div class="caption">
{}_{des}$. </div>
</div>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
